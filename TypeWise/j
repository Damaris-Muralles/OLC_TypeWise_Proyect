%{
	const TIPO_EXPRESION	= require('./instrucciones').TIPO_EXPRESION;
	const TIPO_VALOR 		= require('./instrucciones').TIPO_VALOR;
	const TIPO_DATO			= require('./tabla_simbolos').TIPO_DATO; 
	const instruccionesAPI	= require('./instrucciones').instruccionesAPI;
	let mainEncontrado = false;
	let expglobal=true;
%}


/*=============================== PRESEDENCIA====== */


%right 'UMENOS'
%nonassoc 'POTENCIA' //%nonassoc
%left 'DIVIDIDO', 'POR', "MODULO"
%left 'MAS', 'MENOS'
%left 'DOBLEIG', 'NOIG', 'MENQUE', 'MENIGQUE', 'MAYQUE', 'MAYIGQUE'
%right 'NOT'
%left 'AND'
%left 'OR'
//%right 'PARIZQ'


/* ========================================GRAMATICA======= */
%start ini

%% 

ini
	: instrucciones EOF {
		// cuado se haya reconocido la entrada completa retornamos el AST
		return $1;
	}
;

instrucciones
	: instrucciones instruccion 	{ $1.push($2); $$ = $1; }
	| instruccion					{ $$ = [$1]; }
;

instruccion
	: declaracion  PTCOMA	              { $$ = $1; }
	| asignacion   PTCOMA                { $$ = $1; }
	| funcion_main     PTCOMA               { $$ = $1; }
	| llamada_funcion 	PTCOMA           { $$ = $1; }
	| funcion                     { $$ = $1; }
	/*
	
	| if                          { $$ = $1; }
	| while                       { $$ = $1; }*/
	| error { console.error('Este es un error sintáctico: ' + yytext + ', en la linea: ' + this._$.first_line + ', en la columna: ' + this._$.first_column); }
;


declaracion
    : tipos
        { $$ = instruccionesAPI.nuevoDeclaracion($1.identificador,$1.tipo, expglobal); }
	|T_BOOLEAN IDENTIFICADOR 
        { $$ = instruccionesAPI.nuevoDeclaracion($2,TIPO_DATO.BOOLEAN, expglobal); }
    | tipos IGUAL expresion
        { $$ = instruccionesAPI.nuevoDecAsig($1.identificador,$1.tipo,$3, expglobal); }
	| T_BOOLEAN IDENTIFICADOR IGUAL expresion 
        { $$ = instruccionesAPI.nuevoDecAsig($2,TIPO_DATO.BOOLEAN,$4, expglobal); }
    | T_BOOLEAN IDENTIFICADOR IGUAL expresion_logica 
        { $$ = instruccionesAPI.nuevoDecAsig($2,TIPO_DATO.BOOLEAN,$4,  expglobal); }
    
;
tipos
	: T_INT IDENTIFICADOR { $$ = {tipo: TIPO_DATO.INT, identificador: $2}; }
    | T_DOUBLE IDENTIFICADOR { $$ = {tipo: TIPO_DATO.DOUBLE, identificador: $2}; }
    | T_CHAR IDENTIFICADOR { $$ = {tipo: TIPO_DATO.CHAR, identificador: $2}; }
    | T_STRING IDENTIFICADOR { $$ = {tipo: TIPO_DATO.STRING, identificador: $2}; }
;

asignacion
	: IDENTIFICADOR IGUAL expresion 
        { $$ = instruccionesAPI.nuevoAsignacion($1,$3); }
    | IDENTIFICADOR IGUAL expresion_logica 
        { $$ = instruccionesAPI.nuevoAsignacion($1,$3); }
;

funcion_main
	: T_MAIN llamada_funcion
        {  if (!mainEncontrado) {
                mainEncontrado = true;
                $$ = instruccionesAPI.nuevoMain($2);
            } else {
               console.error('Se encontró más de una función main: en la linea: ' + this._$.first_line + ', en la columna: ' + this._$.first_column);
			}
		}
	
;

llamada_funcion
    : IDENTIFICADOR PARIZQ PARDER
         { $$ = instruccionesAPI.nuevoLlamadaFuncion($1, []); }
    | IDENTIFICADOR PARIZQ expresionllamada PARDER
         { $$ = instruccionesAPI.nuevoLlamadaFuncion($1, $3); }
;
expresionllamada
    : expresionllamada COMA expresion { $1.push($3); $$ = $1; }
    | expresion { $$ = [$1]; }
;

funcion
	: T_VOID IDENTIFICADOR PARIZQ PARDER bloqueinstrucciones
	{$$ = instruccionesAPI.nuevaFuncion($2,[],$5);}
	| T_VOID IDENTIFICADOR PARIZQ parametrosllamada PARDER bloqueinstrucciones
	{$$ = instruccionesAPI.nuevaFuncion($2,$4,$6);}
;
parametrosllamada
    : parametrosllamada COMA tipos { $1.push($3); $$ = $1; }
    | parametrosllamada COMA T_BOOLEAN IDENTIFICADOR { $1.push({tipo: TIPO_DATO.BOOLEAN, identificador: $4}); $$ = $1; } 
	|tipos { $$ = [$1]; }
	| T_BOOLEAN IDENTIFICADOR{ $$ = [{tipo: TIPO_DATO.BOOLEAN, identificador: $4}]; }
;
bloqueinstrucciones
	: LLAVIZQ instruccionesfuncion LLAVDER
	{$$ = $2;}
	| LLAVIZQ LLAVDER {$$ = [];}
;

instruccionesfuncion
	: instruccionesfuncion instruccionfuncion 	{ $1.push($2); $$ = $1; }
	| instruccionfuncion					{ $$ = [$1]; }
;

instruccionfuncion
	: declaracion  PTCOMA	              { $$ = $1; }
	| asignacion   PTCOMA                { $$ = $1; }
	| llamada_funcion 	PTCOMA           { $$ = $1; }
	/*
	
	| if                          { $$ = $1; }
	| while                       { $$ = $1; }*/
	| error { console.error('Este es un error sintáctico: ' + yytext + ', en la linea: ' + this._$.first_line + ', en la columna: ' + this._$.first_column); }
;

expresion
	:  CADENA											{ $$ = instruccionesAPI.nuevoValor($1, TIPO_VALOR.CADENA); }
	| ENTERO											{ $$ = instruccionesAPI.nuevoValor(Number($1), TIPO_VALOR.INT); }
	| DECIMAL											{ $$ = instruccionesAPI.nuevoValor(Number($1), TIPO_VALOR.DOUBLE); }
	| BOOLEANO											{ $$ = instruccionesAPI.nuevoValor($1, TIPO_VALOR.BOOLEAN); }
	| CARACTER											{ $$ = instruccionesAPI.nuevoValor($1.charAt(0), TIPO_VALOR.CARACTER); }
	| IDENTIFICADOR										{ $$ = instruccionesAPI.nuevoValor($1, TIPO_VALOR.IDENTIFICADOR); }
	| MENOS expresion %prec UMENOS						{ $$ = instruccionesAPI.nuevoOperacionUnaria($2, TIPO_EXPRESION.NEGATIVO); }
	| expresion MAS expresion							{  if ($1.tipo === TIPO_VALOR.CADENA || $3.tipo == TIPO_VALOR.CADENA||($1.tipo === TIPO_VALOR.CARACTER && $3.tipo == TIPO_VALOR.CARACTER)) {
																$$ = instruccionesAPI.nuevoOperacionBinaria($1, $3, TIPO_EXPRESION.CONCATENACION);
															} else {
																$$ = instruccionesAPI.nuevoOperacionBinaria($1, $3, TIPO_EXPRESION.SUMA);
															}
														}
	| expresion MENOS expresion							{ $$ = instruccionesAPI.nuevoOperacionBinaria($1, $3, TIPO_EXPRESION.RESTA); }
	| expresion POR expresion							{ $$ = instruccionesAPI.nuevoOperacionBinaria($1, $3, TIPO_EXPRESION.MULTIPLICACION); }
	| expresion DIVIDIDO expresion						{ $$ = instruccionesAPI.nuevoOperacionBinaria($1, $3, TIPO_EXPRESION.DIVISION); }
	| expresion POTENCIA expresion						{ $$ = instruccionesAPI.nuevoOperacionBinaria($1, $3, TIPO_EXPRESION.POTENCIA); }
	| expresion MODULO expresion						{ $$ = instruccionesAPI.nuevoOperacionBinaria($1, $3, TIPO_EXPRESION.MODULO); }
	| PARIZQ expresion PARDER							{ $$ = $2; }
	| llamada_funcion                 					 { $$ = $1; }
	
;
expresion_relacional
	: expresion MAYQUE expresion		{ $$ = instruccionesAPI.nuevoOperacionBinaria($1, $3, TIPO_EXPRESION.MAYOR_QUE); }
	| expresion MENQUE expresion		{ $$ = instruccionesAPI.nuevoOperacionBinaria($1, $3, TIPO_EXPRESION.MENOR_QUE); }
	| expresion MAYIGQUE expresion	{ $$ = instruccionesAPI.nuevoOperacionBinaria($1, $3, TIPO_EXPRESION.MAYOR_IGUAL); }
	| expresion MENIGQUE expresion	{ $$ = instruccionesAPI.nuevoOperacionBinaria($1, $3, TIPO_EXPRESION.MENOR_IGUAL); }
	| expresion DOBLEIG expresion			{ $$ = instruccionesAPI.nuevoOperacionBinaria($1, $3, TIPO_EXPRESION.DOBLE_IGUAL); }
	| expresion NOIG expresion			{ $$ = instruccionesAPI.nuevoOperacionBinaria($1, $3, TIPO_EXPRESION.NO_IGUAL); }

;
expresion_logica
    : expresionescompuestas AND expresionescompuestas { $$ = instruccionesAPI.nuevoOperacionBinaria($1, $3, TIPO_EXPRESION.AND); }
    | expresionescompuestas OR expresionescompuestas { $$ = instruccionesAPI.nuevoOperacionBinaria($1, $3, TIPO_EXPRESION.OR); }
    | NOT expresionescompuestas { $$ = instruccionesAPI.nuevoOperacionUnaria($2, TIPO_EXPRESION.NOT); }
	| expresion_relacional { $$ = $1; }

;
expresionescompuestas
	:expresion_logica{ $$ = $1; }
	| expresion{ $$ = $1; }
;




La función agregar que has proporcionado agrega un nuevo símbolo al ámbito actual. Si deseas agregar un símbolo solo si no existe en el ámbito local o en los ámbitos padres, puedes modificar la función para que primero busque el símbolo en el ámbito local y en los ámbitos padres antes de agregarlo. Aquí hay un ejemplo de cómo podrías hacerlo:


agregar(id, tipo) {
    if (!this.buscar(id)) {
        const nuevoSimbolo = crearSimbolo(id, tipo);
        this._simbolos.push(nuevoSimbolo);
    } else {
        // manejar el caso en que el símbolo ya existe en el ámbito local o en los ámbitos padres
    }
}

buscar(id) {
    let simbolo = this._simbolos.filter(simbolo => simbolo.id === id)[0];
    if (simbolo) {
        return simbolo;
    } else if (this.padre) {
        return this.padre.buscar(id);
    } else {
        return null;
    }
}a.push(...b);

 if (erroractualizacion.length==0){
                
    }else{
        erroreslist.push(...erroractualizacion);
    }




try {
  // Tu código aquí
  throw 'ERROR: variable: ' + id + ' no ha sido definida';
} catch (error) {
  var textarea = document.getElementById('myTextarea');
  textarea.value = error;
}